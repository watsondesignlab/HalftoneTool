<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HALFTONE STUDIO</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #fafafa;
            color: #000;
            overflow: hidden;
            font-weight: 400;
            letter-spacing: -0.01em;
        }

        .container {
            display: flex;
            height: 100vh;
        }

        .canvas-area {
            flex: 1;
            position: relative;
            background: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            border-right: 1px solid #e5e5e5;
        }

        .upload-zone {
            border: 2px dashed #d4d4d4;
            border-radius: 4px;
            padding: 80px 60px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            background: #fafafa;
            max-width: 400px;
        }

        .upload-zone:hover {
            border-color: #000;
            background: #f5f5f5;
        }

        .upload-zone.dragover {
            border-color: #000;
            background: #f0f0f0;
        }

        .upload-text {
            font-size: 16px;
            margin-bottom: 8px;
            font-weight: 500;
            color: #000;
        }

        .upload-subtext {
            color: #737373;
            font-size: 14px;
            font-weight: 400;
        }

        .canvas-container {
            position: relative;
            overflow: hidden;
            cursor: grab;
        }

        .canvas-container:active {
            cursor: grabbing;
        }

        #preview-canvas {
            display: block;
            border: 1px solid #e5e5e5;
        }

        .toolbar {
            width: 320px;
            background: #fff;
            padding: 32px 24px;
            display: flex;
            flex-direction: column;
            gap: 24px;
            border-left: 1px solid #e5e5e5;
            overflow-y: auto;
        }

        .toolbar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 24px;
            border-bottom: 1px solid #e5e5e5;
        }

        .logo {
            font-size: 18px;
            font-weight: 700;
            letter-spacing: -0.02em;
        }

        .new-btn {
            background: none;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .new-btn:hover {
            border-color: #000;
            background: #fafafa;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .control-item {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #404040;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            font-weight: 400;
            color: #000;
        }

        .slider {
            -webkit-appearance: none;
            appearance: none;
            height: 2px;
            background: #e5e5e5;
            outline: none;
            border-radius: 1px;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #000;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #000;
            cursor: pointer;
            border-radius: 50%;
            border: none;
        }

        .color-picker {
            -webkit-appearance: none;
            appearance: none;
            width: 40px;
            height: 40px;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            cursor: pointer;
            outline: none;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 3px;
        }

        .shape-select, .fit-select {
            -webkit-appearance: none;
            appearance: none;
            background: #fff;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            cursor: pointer;
            outline: none;
            font-family: inherit;
            font-weight: 500;
        }

        .shape-select:hover, .fit-select:hover {
            border-color: #000;
        }

        .dimension-input {
            -webkit-appearance: none;
            appearance: none;
            background: #fff;
            border: 1px solid #d4d4d4;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 12px;
            outline: none;
            font-family: inherit;
            font-weight: 500;
            width: 80px;
        }

        .dimension-input:hover, .dimension-input:focus {
            border-color: #000;
        }

        .dimension-row {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .dimension-label {
            font-size: 11px;
            color: #737373;
            min-width: 20px;
        }

        .export-section {
            margin-top: auto;
            padding-top: 32px;
            border-top: 1px solid #e5e5e5;
        }

        .export-btn {
            width: 100%;
            background: #000;
            color: #fff;
            border: none;
            border-radius: 4px;
            padding: 12px 16px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-family: inherit;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 8px;
        }

        .export-btn:hover {
            background: #262626;
        }

        .export-btn:disabled {
            background: #d4d4d4;
            cursor: not-allowed;
        }

        .export-btn.secondary {
            background: #fff;
            color: #000;
            border: 1px solid #d4d4d4;
        }

        .export-btn.secondary:hover {
            border-color: #000;
            background: #fafafa;
        }

        .hidden {
            display: none !important;
        }

        #file-input {
            display: none;
        }

        .pan-controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 8px;
            display: none;
            gap: 4px;
        }

        .pan-btn {
            background: none;
            border: 1px solid #d4d4d4;
            border-radius: 2px;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
            font-family: inherit;
            font-weight: 500;
        }

        .pan-btn:hover {
            border-color: #000;
        }

        .image-info {
            position: absolute;
            top: 16px;
            left: 16px;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(10px);
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 8px 12px;
            font-size: 11px;
            font-weight: 500;
            display: none;
        }

        .section-header {
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: #737373;
            margin-bottom: 8px;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }
            
            .toolbar {
                width: 100%;
                order: -1;
                padding: 16px;
                flex-direction: row;
                overflow-x: auto;
                gap: 16px;
            }
            
            .canvas-area {
                border-right: none;
                border-top: 1px solid #e5e5e5;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="canvas-area">
            <div class="upload-zone" id="upload-zone">
                <div class="upload-text">Drop image here</div>
                <div class="upload-subtext">or click to browse</div>
            </div>
            
            <div class="canvas-container hidden" id="canvas-container">
                <canvas id="preview-canvas"></canvas>
                <div class="image-info" id="image-info"></div>
                <div class="pan-controls" id="pan-controls">
                    <button class="pan-btn" onclick="processor.resetView()">FIT</button>
                    <button class="pan-btn" onclick="processor.zoom(1.2)">+</button>
                    <button class="pan-btn" onclick="processor.zoom(0.8)">−</button>
                </div>
            </div>
        </div>

        <div class="toolbar">
            <div class="toolbar-header">
                <div class="logo">HALFTONE STUDIO</div>
                <button class="new-btn" id="new-btn">NEW</button>
            </div>

            <div class="control-group">
                <div class="section-header">Image Transform</div>
                <div class="control-item">
                    <label class="control-label">
                        Scale
                        <span class="control-value" id="scale-value">100%</span>
                    </label>
                    <input type="range" class="slider" id="image-scale" min="50" max="300" value="100">
                </div>
                
                <div class="control-item">
                    <label class="control-label">
                        X Position
                        <span class="control-value" id="x-pos-value">0</span>
                    </label>
                    <input type="range" class="slider" id="x-position" min="-100" max="100" value="0">
                </div>
                
                <div class="control-item">
                    <label class="control-label">
                        Y Position
                        <span class="control-value" id="y-pos-value">0</span>
                    </label>
                    <input type="range" class="slider" id="y-position" min="-100" max="100" value="0">
                </div>
            </div>

            <div class="control-group">
                <div class="section-header">Halftone Settings</div>
                <div class="control-item">
                    <label class="control-label">
                        Dot Size
                        <span class="control-value" id="dot-size-value">10px</span>
                    </label>
                    <input type="range" class="slider" id="dot-size" min="2" max="200" value="10">
                </div>
                
                <div class="control-item">
                    <label class="control-label">Dot Shape</label>
                    <select class="shape-select" id="dot-shape">
                        <option value="square">Square</option>
                        <option value="circle">Circle</option>
                        <option value="mixed">Mixed Random</option>
                    </select>
                </div>
                
                <div class="control-item">
                    <label class="control-label">Dot Color</label>
                    <input type="color" class="color-picker" id="dot-color" value="#000000">
                </div>
            </div>

            <div class="control-group">
                <div class="section-header">Image Adjustments</div>
                <div class="control-item">
                    <label class="control-label">
                        Brightness
                        <span class="control-value" id="brightness-value">0</span>
                    </label>
                    <input type="range" class="slider" id="brightness" min="-100" max="100" value="0">
                </div>
                
                <div class="control-item">
                    <label class="control-label">
                        Contrast
                        <span class="control-value" id="contrast-value">0</span>
                    </label>
                    <input type="range" class="slider" id="contrast" min="-100" max="100" value="0">
                </div>
            </div>

            <div class="export-section">
                <button class="export-btn" id="export-svg" disabled>Export SVG</button>
                <button class="export-btn secondary" id="export-png" disabled>Export PNG</button>
            </div>
        </div>
    </div>

    <input type="file" id="file-input" accept="image/*">

    <script>
        class HalftoneProcessor {
            constructor() {
                this.canvas = document.getElementById('preview-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.originalImage = null;
                this.processedImageData = null;
                this.previewImageData = null;
                this.uploaded = false;
                
                // Output settings (fixed 24x36 at 300 DPI)
                this.widthInches = 24;
                this.heightInches = 36;
                this.dpi = 300;
                
                // Preview settings for smooth interaction
                this.previewScale = 0.25; // Preview at 25% resolution for speed
                this.previewWidth = Math.round(this.widthInches * this.dpi * this.previewScale);
                this.previewHeight = Math.round(this.heightInches * this.dpi * this.previewScale);
                
                // Image transform controls
                this.imageScale = 100; // 50-300%
                this.xPosition = 0; // -100 to 100
                this.yPosition = 0; // -100 to 100
                
                // Halftone settings
                this.dotSize = 10;
                this.dotColor = '#000000';
                this.dotShape = 'square';
                
                // Image adjustments (using -100 to 100 range)
                this.brightness = 0;
                this.contrast = 0;
                
                // Pan and zoom
                this.offsetX = 0;
                this.offsetY = 0;
                this.scale = 1;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                // Debounce timer for smooth interactions
                this.updateTimer = null;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                const uploadZone = document.getElementById('upload-zone');
                const fileInput = document.getElementById('file-input');
                
                // File upload
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });
                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.classList.remove('dragover');
                });
                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFile(files[0]);
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFile(e.target.files[0]);
                    }
                });

                // New button
                document.getElementById('new-btn').addEventListener('click', () => {
                    fileInput.click();
                });

                // Image transform controls
                document.getElementById('image-scale').addEventListener('input', (e) => {
                    this.imageScale = parseInt(e.target.value);
                    document.getElementById('scale-value').textContent = e.target.value + '%';
                    this.debouncedUpdate();
                });

                document.getElementById('x-position').addEventListener('input', (e) => {
                    this.xPosition = parseInt(e.target.value);
                    document.getElementById('x-pos-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                document.getElementById('y-position').addEventListener('input', (e) => {
                    this.yPosition = parseInt(e.target.value);
                    document.getElementById('y-pos-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                // Halftone controls
                document.getElementById('dot-size').addEventListener('input', (e) => {
                    this.dotSize = parseInt(e.target.value);
                    document.getElementById('dot-size-value').textContent = e.target.value + 'px';
                    this.debouncedDraw();
                });

                document.getElementById('dot-color').addEventListener('change', (e) => {
                    this.dotColor = e.target.value;
                    this.draw();
                });

                document.getElementById('dot-shape').addEventListener('change', (e) => {
                    this.dotShape = e.target.value;
                    this.draw();
                });

                // Image adjustment controls
                document.getElementById('brightness').addEventListener('input', (e) => {
                    this.brightness = parseInt(e.target.value);
                    document.getElementById('brightness-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                document.getElementById('contrast').addEventListener('input', (e) => {
                    this.contrast = parseInt(e.target.value);
                    document.getElementById('contrast-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                // Canvas pan/zoom
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Export
                document.getElementById('export-svg').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.exportSVG();
                });
                
                document.getElementById('export-png').addEventListener('click', (e) => {
                    e.preventDefault(); 
                    this.exportPNG();
                });
            }

            handleFile(file) {
                if (file.type.startsWith('image/')) {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.uploaded = true;
                        this.updateCanvas();
                        this.processPreviewImage();
                        this.resetView();
                        this.draw();
                        this.showCanvas();
                        this.updateImageInfo();
                    };
                    img.src = URL.createObjectURL(file);
                } else {
                    console.error('Not an image file');
                }
            }

            updateCanvas() {
                if (!this.uploaded || !this.originalImage) return;
                
                // Set canvas size to preview dimensions for smooth interaction
                this.canvas.width = this.previewWidth;
                this.canvas.height = this.previewHeight;
                
                // Calculate display size for preview (max 800px wide or 600px tall)
                const maxDisplayWidth = 800;
                const maxDisplayHeight = 600;
                const displayScale = Math.min(
                    maxDisplayWidth / this.previewWidth,
                    maxDisplayHeight / this.previewHeight,
                    1
                );
                
                this.canvas.style.width = (this.previewWidth * displayScale) + 'px';
                this.canvas.style.height = (this.previewHeight * displayScale) + 'px';
            }

            // Debounced update for smooth slider interaction
            debouncedUpdate() {
                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    this.processPreviewImage();
                    this.draw();
                }, 50); // 50ms delay for smooth interaction
            }

            // Debounced draw for dot size changes
            debouncedDraw() {
                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    this.draw();
                }, 30); // Faster for draw-only changes
            }

            processPreviewImage() {
                if (!this.uploaded || !this.originalImage) return;

                // Create temp canvas at preview resolution
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.previewWidth;
                tempCanvas.height = this.previewHeight;
                
                // Fill with white background
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, this.previewWidth, this.previewHeight);
                
                // Calculate base scale to fill the entire canvas (true fill)
                const scaleX = this.previewWidth / this.originalImage.width;
                const scaleY = this.previewHeight / this.originalImage.height;
                const baseFillScale = Math.max(scaleX, scaleY);
                
                // Apply user scale adjustment
                const finalScale = baseFillScale * (this.imageScale / 100);
                
                // Calculate scaled dimensions
                const scaledWidth = this.originalImage.width * finalScale;
                const scaledHeight = this.originalImage.height * finalScale;
                
                // Calculate position with user offset
                const maxOffsetX = Math.max(0, (scaledWidth - this.previewWidth) / 2);
                const maxOffsetY = Math.max(0, (scaledHeight - this.previewHeight) / 2);
                
                const offsetX = (this.xPosition / 100) * maxOffsetX;
                const offsetY = (this.yPosition / 100) * maxOffsetY;
                
                // Calculate final draw position
                const drawX = (this.previewWidth - scaledWidth) / 2 - offsetX;
                const drawY = (this.previewHeight - scaledHeight) / 2 - offsetY;
                
                // Draw the scaled and positioned image
                tempCtx.drawImage(
                    this.originalImage, 
                    drawX, drawY, 
                    scaledWidth, scaledHeight
                );
                
                // Get image data and apply brightness/contrast
                const imageData = tempCtx.getImageData(0, 0, this.previewWidth, this.previewHeight);
                const data = imageData.data;
                
                // Convert -100 to 100 range to multipliers
                const brightnessFactor = (this.brightness + 100) / 100;
                const contrastFactor = (this.contrast + 100) / 100;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply brightness
                    let r = data[i] * brightnessFactor;
                    let g = data[i + 1] * brightnessFactor;
                    let b = data[i + 2] * brightnessFactor;
                    
                    // Apply contrast
                    r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    
                    // Clamp values
                    data[i] = Math.max(0, Math.min(255, r));
                    data[i + 1] = Math.max(0, Math.min(255, g));
                    data[i + 2] = Math.max(0, Math.min(255, b));
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                this.previewImageData = tempCtx.getImageData(0, 0, this.previewWidth, this.previewHeight);
            }

            processImage() {
                if (!this.uploaded || !this.originalImage) return;

                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                // Create temp canvas for processing at full resolution
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = outputWidth;
                tempCanvas.height = outputHeight;
                
                // Fill with white background
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, outputWidth, outputHeight);
                
                // Calculate base scale to fill the entire canvas (true fill)
                const scaleX = outputWidth / this.originalImage.width;
                const scaleY = outputHeight / this.originalImage.height;
                const baseFillScale = Math.max(scaleX, scaleY);
                
                // Apply user scale adjustment
                const finalScale = baseFillScale * (this.imageScale / 100);
                
                // Calculate scaled dimensions
                const scaledWidth = this.originalImage.width * finalScale;
                const scaledHeight = this.originalImage.height * finalScale;
                
                // Calculate position with user offset
                const maxOffsetX = Math.max(0, (scaledWidth - outputWidth) / 2);
                const maxOffsetY = Math.max(0, (scaledHeight - outputHeight) / 2);
                
                const offsetX = (this.xPosition / 100) * maxOffsetX;
                const offsetY = (this.yPosition / 100) * maxOffsetY;
                
                // Calculate final draw position
                const drawX = (outputWidth - scaledWidth) / 2 - offsetX;
                const drawY = (outputHeight - scaledHeight) / 2 - offsetY;
                
                // Draw the scaled and positioned image
                tempCtx.drawImage(
                    this.originalImage, 
                    drawX, drawY, 
                    scaledWidth, scaledHeight
                );
                
                // Get image data and apply brightness/contrast
                const imageData = tempCtx.getImageData(0, 0, outputWidth, outputHeight);
                const data = imageData.data;
                
                // Convert -100 to 100 range to multipliers
                const brightnessFactor = (this.brightness + 100) / 100;
                const contrastFactor = (this.contrast + 100) / 100;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply brightness
                    let r = data[i] * brightnessFactor;
                    let g = data[i + 1] * brightnessFactor;
                    let b = data[i + 2] * brightnessFactor;
                    
                    // Apply contrast
                    r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    
                    // Clamp values
                    data[i] = Math.max(0, Math.min(255, r));
                    data[i + 1] = Math.max(0, Math.min(255, g));
                    data[i + 2] = Math.max(0, Math.min(255, b));
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                this.processedImageData = tempCtx.getImageData(0, 0, outputWidth, outputHeight);
            }

            showCanvas() {
                document.getElementById('upload-zone').classList.add('hidden');
                document.getElementById('canvas-container').classList.remove('hidden');
                document.getElementById('pan-controls').style.display = 'flex';
                document.getElementById('image-info').style.display = 'block';
                document.getElementById('export-svg').disabled = false;
                document.getElementById('export-png').disabled = false;
            }

            updateImageInfo() {
                const info = document.getElementById('image-info');
                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                info.textContent = `24" × 36" @ 300dpi (${outputWidth} × ${outputHeight}px)`;
            }

            draw() {
                if (!this.uploaded || !this.previewImageData) return;

                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;

                // Clear and set white background
                this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const pixels = this.previewImageData.data;
                this.ctx.fillStyle = this.dotColor;

                // Scale dot size for preview resolution
                const previewDotSize = Math.max(1, Math.round(this.dotSize * this.previewScale));

                // Loop through preview image in steps of scaled dot size
                for (let y = 0; y < canvasHeight; y += previewDotSize) {
                    for (let x = 0; x < canvasWidth; x += previewDotSize) {
                        // Sample pixel at center of dot area
                        const sampleX = Math.min(x + previewDotSize / 2, canvasWidth - 1);
                        const sampleY = Math.min(y + previewDotSize / 2, canvasHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * canvasWidth) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        // Calculate brightness
                        const brightnessValue = (r + g + b) / 3;
                        
                        // Map brightness to dot size
                        const dotRadius = this.map(brightnessValue, 0, 255, previewDotSize * 0.9, 0.5);
                        
                        // Draw dot based on shape setting
                        if (dotRadius > 0.5) {
                            const centerX = x + previewDotSize / 2;
                            const centerY = y + previewDotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                this.ctx.beginPath();
                                this.ctx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                this.ctx.fill();
                            } else if (this.dotShape === 'square') {
                                this.ctx.fillRect(
                                    centerX - dotRadius / 2,
                                    centerY - dotRadius / 2,
                                    dotRadius,
                                    dotRadius
                                );
                            } else if (this.dotShape === 'mixed') {
                                // Deterministic random based on position
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    this.ctx.beginPath();
                                    this.ctx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                    this.ctx.fill();
                                } else {
                                    this.ctx.fillRect(
                                        centerX - dotRadius / 2,
                                        centerY - dotRadius / 2,
                                        dotRadius,
                                        dotRadius
                                    );
                                }
                            }
                        }
                    }
                }
                
                this.updateImageInfo();
            }

            // Helper function to mimic P5.js map function
            map(value, start1, stop1, start2, stop2) {
                return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
            }

            // Pan and zoom functionality
            startDrag(e) {
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            drag(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.offsetX += deltaX;
                this.offsetY += deltaY;
                
                this.updateCanvasTransform();
                
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            endDrag() {
                this.isDragging = false;
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom(zoomFactor);
            }

            zoom(factor) {
                this.scale *= factor;
                this.scale = Math.max(0.1, Math.min(3, this.scale));
                this.updateCanvasTransform();
            }

            resetView() {
                this.offsetX = 0;
                this.offsetY = 0;
                this.scale = 1;
                this.updateCanvasTransform();
            }

            updateCanvasTransform() {
                this.canvas.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
            }

            // Export functions - these process at full resolution
            exportSVG() {
                if (!this.uploaded || !this.originalImage) {
                    alert('Please upload an image first');
                    return;
                }

                // Generate full resolution image data for export
                this.processImage();

                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                let svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${outputWidth}" height="${outputHeight}" viewBox="0 0 ${outputWidth} ${outputHeight}">`;
                svg += `<rect width="${outputWidth}" height="${outputHeight}" fill="white"/>`;
                
                const pixels = this.processedImageData.data;

                // Generate SVG dots at full resolution
                for (let y = 0; y < outputHeight; y += this.dotSize) {
                    for (let x = 0; x < outputWidth; x += this.dotSize) {
                        const sampleX = Math.min(x + this.dotSize / 2, outputWidth - 1);
                        const sampleY = Math.min(y + this.dotSize / 2, outputHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * outputWidth) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        const brightnessValue = (r + g + b) / 3;
                        const dotRadius = this.map(brightnessValue, 0, 255, this.dotSize * 0.9, 0.5);
                        
                        if (dotRadius > 0.5) {
                            const centerX = x + this.dotSize / 2;
                            const centerY = y + this.dotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'square') {
                                svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'mixed') {
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                                } else {
                                    svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                                }
                            }
                        }
                    }
                }
                
                svg += '</svg>';
                
                // Generate timestamp filename
                const now = new Date();
                const timestamp = `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1)
                    .toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now
                    .getHours().toString().padStart(2, '0')}${now.getMinutes()
                    .toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
                
                const filename = `halftone_24x36_300dpi_${timestamp}.svg`;
                
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                this.downloadFile(blob, filename);
            }

            exportPNG() {
                if (!this.uploaded || !this.originalImage) {
                    alert('Please upload an image first');
                    return;
                }

                // Create full resolution canvas for export
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                exportCanvas.width = outputWidth;
                exportCanvas.height = outputHeight;

                // Generate full resolution image data
                this.processImage();
                
                // Clear and set white background
                exportCtx.clearRect(0, 0, outputWidth, outputHeight);
                exportCtx.fillStyle = '#ffffff';
                exportCtx.fillRect(0, 0, outputWidth, outputHeight);

                const pixels = this.processedImageData.data;
                exportCtx.fillStyle = this.dotColor;

                // Draw at full resolution
                for (let y = 0; y < outputHeight; y += this.dotSize) {
                    for (let x = 0; x < outputWidth; x += this.dotSize) {
                        const sampleX = Math.min(x + this.dotSize / 2, outputWidth - 1);
                        const sampleY = Math.min(y + this.dotSize / 2, outputHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * outputWidth) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        const brightnessValue = (r + g + b) / 3;
                        const dotRadius = this.map(brightnessValue, 0, 255, this.dotSize * 0.9, 0.5);
                        
                        if (dotRadius > 0.5) {
                            const centerX = x + this.dotSize / 2;
                            const centerY = y + this.dotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                exportCtx.beginPath();
                                exportCtx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                exportCtx.fill();
                            } else if (this.dotShape === 'square') {
                                exportCtx.fillRect(
                                    centerX - dotRadius / 2,
                                    centerY - dotRadius / 2,
                                    dotRadius,
                                    dotRadius
                                );
                            } else if (this.dotShape === 'mixed') {
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    exportCtx.beginPath();
                                    exportCtx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                    exportCtx.fill();
                                } else {
                                    exportCtx.fillRect(
                                        centerX - dotRadius / 2,
                                        centerY - dotRadius / 2,
                                        dotRadius,
                                        dotRadius
                                    );
                                }
                            }
                        }
                    }
                }

                // Generate timestamp filename
                const now = new Date();
                const timestamp = `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1)
                    .toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now
                    .getHours().toString().padStart(2, '0')}${now.getMinutes()
                    .toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
                
                const filename = `halftone_24x36_300dpi_${timestamp}.png`;
                
                exportCanvas.toBlob((blob) => {
                    if (!blob) {
                        alert('PNG Export failed - could not create image data.');
                        return;
                    }
                    this.downloadFile(blob, filename);
                }, 'image/png', 1.0);
            }

            downloadFile(blob, filename) {
                // Try modern File System Access API first
                if (window.showSaveFilePicker) {
                    const fileExtension = filename.split('.').pop();
                    const mimeType = fileExtension === 'svg' ? 'image/svg+xml' : 'image/png';
                    
                    window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: `${fileExtension.toUpperCase()} files`,
                            accept: {[mimeType]: [`.${fileExtension}`]},
                        }],
                    }).then(fileHandle => {
                        return fileHandle.createWritable();
                    }).then(writable => {
                        return writable.write(blob);
                    }).then(writable => {
                        return writable.close();
                    }).catch(err => {
                        if (err.name !== 'AbortError') {
                            this.fallbackDownload(blob, filename);
                        }
                    });
                } else {
                    this.fallbackDownload(blob, filename);
                }
            }

            fallbackDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 1000);
            }
        }

        // Initialize
        const processor = new HalftoneProcessor();
    </script>dImageData = null;
                this.previewImageData = null;
                this.uploaded = false;
                
                // Output settings (fixed 24x36 at 300 DPI)
                this.widthInches = 24;
                this.heightInches = 36;
                this.dpi = 300;
                
                // Preview settings for smooth interaction
                this.previewScale = 0.25; // Preview at 25% resolution for speed
                this.previewWidth = Math.round(this.widthInches * this.dpi * this.previewScale);
                this.previewHeight = Math.round(this.heightInches * this.dpi * this.previewScale);
                
                // Image transform controls
                this.imageScale = 100; // 50-300%
                this.xPosition = 0; // -100 to 100
                this.yPosition = 0; // -100 to 100
                
                // Debounce timer for smooth interactions
                this.updateTimer = null;
                
                // Halftone settings
                this.dotSize = 10;
                this.dotColor = '#000000';
                this.dotShape = 'square';
                
                // Image adjustments (using -100 to 100 range)
                this.brightness = 0;
                this.contrast = 0;
                
                // Pan and zoom
                this.offsetX = 0;
                this.offsetY = 0;
                this.scale = 1;
                this.isDragging = false;
                this.lastMouseX = 0;
                this.lastMouseY = 0;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                const uploadZone = document.getElementById('upload-zone');
                const fileInput = document.getElementById('file-input');
                
                // File upload
                uploadZone.addEventListener('click', () => fileInput.click());
                uploadZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadZone.classList.add('dragover');
                });
                uploadZone.addEventListener('dragleave', () => {
                    uploadZone.classList.remove('dragover');
                });
                uploadZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadZone.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFile(files[0]);
                    }
                });

                fileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFile(e.target.files[0]);
                    }
                });

                // New button
                document.getElementById('new-btn').addEventListener('click', () => {
                    fileInput.click();
                });

                // Image transform controls
                document.getElementById('image-scale').addEventListener('input', (e) => {
                    this.imageScale = parseInt(e.target.value);
                    document.getElementById('scale-value').textContent = e.target.value + '%';
                    this.debouncedUpdate();
                });

                document.getElementById('x-position').addEventListener('input', (e) => {
                    this.xPosition = parseInt(e.target.value);
                    document.getElementById('x-pos-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                document.getElementById('y-position').addEventListener('input', (e) => {
                    this.yPosition = parseInt(e.target.value);
                    document.getElementById('y-pos-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                // Halftone controls
                document.getElementById('dot-size').addEventListener('input', (e) => {
                    this.dotSize = parseInt(e.target.value);
                    document.getElementById('dot-size-value').textContent = e.target.value + 'px';
                    this.debouncedDraw();
                });

                document.getElementById('dot-color').addEventListener('change', (e) => {
                    this.dotColor = e.target.value;
                    this.draw();
                });

                document.getElementById('dot-shape').addEventListener('change', (e) => {
                    this.dotShape = e.target.value;
                    this.draw();
                });

                // Image adjustment controls
                document.getElementById('brightness').addEventListener('input', (e) => {
                    this.brightness = parseInt(e.target.value);
                    document.getElementById('brightness-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                document.getElementById('contrast').addEventListener('input', (e) => {
                    this.contrast = parseInt(e.target.value);
                    document.getElementById('contrast-value').textContent = e.target.value;
                    this.debouncedUpdate();
                });

                // Canvas pan/zoom
                this.canvas.addEventListener('mousedown', (e) => this.startDrag(e));
                this.canvas.addEventListener('mousemove', (e) => this.drag(e));
                this.canvas.addEventListener('mouseup', () => this.endDrag());
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // Export
                document.getElementById('export-svg').addEventListener('click', (e) => {
                    e.preventDefault();
                    this.exportSVG();
                });
                
                document.getElementById('export-png').addEventListener('click', (e) => {
                    e.preventDefault(); 
                    this.exportPNG();
                });
            }

            handleFile(file) {
                if (file.type.startsWith('image/')) {
                    const img = new Image();
                    img.onload = () => {
                        this.originalImage = img;
                        this.uploaded = true;
                        this.updateCanvas();
                        this.resetView();
                        this.showCanvas();
                        this.updateImageInfo();
                    };
                    img.src = URL.createObjectURL(file);
                } else {
                    console.error('Not an image file');
                }
            }

            updateCanvas() {
                if (!this.uploaded || !this.originalImage) return;
                
                // Set canvas size to preview dimensions for smooth interaction
                this.canvas.width = this.previewWidth;
                this.canvas.height = this.previewHeight;
                
                // Calculate display size for preview (max 800px wide or 600px tall)
                const maxDisplayWidth = 800;
                const maxDisplayHeight = 600;
                const displayScale = Math.min(
                    maxDisplayWidth / this.previewWidth,
                    maxDisplayHeight / this.previewHeight,
                    1
                );
                
                this.canvas.style.width = (this.previewWidth * displayScale) + 'px';
                this.canvas.style.height = (this.previewHeight * displayScale) + 'px';
            }

            // Debounced update for smooth slider interaction
            debouncedUpdate() {
                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    this.processPreviewImage();
                    this.draw();
                }, 50); // 50ms delay for smooth interaction
            }

            // Debounced draw for dot size changes
            debouncedDraw() {
                clearTimeout(this.updateTimer);
                this.updateTimer = setTimeout(() => {
                    this.draw();
                }, 30); // Faster for draw-only changes
            }

            processPreviewImage() {
                if (!this.uploaded || !this.originalImage) return;

                // Create temp canvas at preview resolution
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = this.previewWidth;
                tempCanvas.height = this.previewHeight;
                
                // Fill with white background
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, this.previewWidth, this.previewHeight);
                
                // Calculate base scale to fill the entire canvas (true fill)
                const scaleX = this.previewWidth / this.originalImage.width;
                const scaleY = this.previewHeight / this.originalImage.height;
                const baseFillScale = Math.max(scaleX, scaleY);
                
                // Apply user scale adjustment
                const finalScale = baseFillScale * (this.imageScale / 100);
                
                // Calculate scaled dimensions
                const scaledWidth = this.originalImage.width * finalScale;
                const scaledHeight = this.originalImage.height * finalScale;
                
                // Calculate position with user offset
                const maxOffsetX = Math.max(0, (scaledWidth - this.previewWidth) / 2);
                const maxOffsetY = Math.max(0, (scaledHeight - this.previewHeight) / 2);
                
                const offsetX = (this.xPosition / 100) * maxOffsetX;
                const offsetY = (this.yPosition / 100) * maxOffsetY;
                
                // Calculate final draw position
                const drawX = (this.previewWidth - scaledWidth) / 2 - offsetX;
                const drawY = (this.previewHeight - scaledHeight) / 2 - offsetY;
                
                // Draw the scaled and positioned image
                tempCtx.drawImage(
                    this.originalImage, 
                    drawX, drawY, 
                    scaledWidth, scaledHeight
                );
                
                // Get image data and apply brightness/contrast
                const imageData = tempCtx.getImageData(0, 0, this.previewWidth, this.previewHeight);
                const data = imageData.data;
                
                // Convert -100 to 100 range to multipliers
                const brightnessFactor = (this.brightness + 100) / 100;
                const contrastFactor = (this.contrast + 100) / 100;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply brightness
                    let r = data[i] * brightnessFactor;
                    let g = data[i + 1] * brightnessFactor;
                    let b = data[i + 2] * brightnessFactor;
                    
                    // Apply contrast
                    r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    
                    // Clamp values
                    data[i] = Math.max(0, Math.min(255, r));
                    data[i + 1] = Math.max(0, Math.min(255, g));
                    data[i + 2] = Math.max(0, Math.min(255, b));
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                this.previewImageData = tempCtx.getImageData(0, 0, this.previewWidth, this.previewHeight);
            }

            processImage() {
                if (!this.uploaded || !this.originalImage) return;

                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                // Create temp canvas for processing at full resolution
                const tempCanvas = document.createElement('canvas');
                const tempCtx = tempCanvas.getContext('2d');
                tempCanvas.width = outputWidth;
                tempCanvas.height = outputHeight;
                
                // Fill with white background
                tempCtx.fillStyle = '#ffffff';
                tempCtx.fillRect(0, 0, outputWidth, outputHeight);
                
                // Calculate base scale to fill the entire canvas (true fill)
                const scaleX = outputWidth / this.originalImage.width;
                const scaleY = outputHeight / this.originalImage.height;
                const baseFillScale = Math.max(scaleX, scaleY);
                
                // Apply user scale adjustment
                const finalScale = baseFillScale * (this.imageScale / 100);
                
                // Calculate scaled dimensions
                const scaledWidth = this.originalImage.width * finalScale;
                const scaledHeight = this.originalImage.height * finalScale;
                
                // Calculate position with user offset
                const maxOffsetX = Math.max(0, (scaledWidth - outputWidth) / 2);
                const maxOffsetY = Math.max(0, (scaledHeight - outputHeight) / 2);
                
                const offsetX = (this.xPosition / 100) * maxOffsetX;
                const offsetY = (this.yPosition / 100) * maxOffsetY;
                
                // Calculate final draw position
                const drawX = (outputWidth - scaledWidth) / 2 - offsetX;
                const drawY = (outputHeight - scaledHeight) / 2 - offsetY;
                
                // Draw the scaled and positioned image
                tempCtx.drawImage(
                    this.originalImage, 
                    drawX, drawY, 
                    scaledWidth, scaledHeight
                );
                
                // Get image data and apply brightness/contrast
                const imageData = tempCtx.getImageData(0, 0, outputWidth, outputHeight);
                const data = imageData.data;
                
                // Convert -100 to 100 range to multipliers
                const brightnessFactor = (this.brightness + 100) / 100;
                const contrastFactor = (this.contrast + 100) / 100;
                
                for (let i = 0; i < data.length; i += 4) {
                    // Apply brightness
                    let r = data[i] * brightnessFactor;
                    let g = data[i + 1] * brightnessFactor;
                    let b = data[i + 2] * brightnessFactor;
                    
                    // Apply contrast
                    r = ((r / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    g = ((g / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    b = ((b / 255 - 0.5) * contrastFactor + 0.5) * 255;
                    
                    // Clamp values
                    data[i] = Math.max(0, Math.min(255, r));
                    data[i + 1] = Math.max(0, Math.min(255, g));
                    data[i + 2] = Math.max(0, Math.min(255, b));
                }
                
                tempCtx.putImageData(imageData, 0, 0);
                this.processedImageData = tempCtx.getImageData(0, 0, outputWidth, outputHeight);
            }

            showCanvas() {
                document.getElementById('upload-zone').classList.add('hidden');
                document.getElementById('canvas-container').classList.remove('hidden');
                document.getElementById('pan-controls').style.display = 'flex';
                document.getElementById('image-info').style.display = 'block';
                document.getElementById('export-svg').disabled = false;
                document.getElementById('export-png').disabled = false;
            }

            updateImageInfo() {
                const info = document.getElementById('image-info');
                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                info.textContent = `24" × 36" @ 300dpi (${outputWidth} × ${outputHeight}px)`;
            }

            draw() {
                if (!this.uploaded || !this.previewImageData) return;

                const canvasWidth = this.canvas.width;
                const canvasHeight = this.canvas.height;

                // Clear and set white background
                this.ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                this.ctx.fillStyle = '#ffffff';
                this.ctx.fillRect(0, 0, canvasWidth, canvasHeight);

                const pixels = this.previewImageData.data;
                this.ctx.fillStyle = this.dotColor;

                // Scale dot size for preview resolution
                const previewDotSize = Math.max(1, Math.round(this.dotSize * this.previewScale));

                // Loop through preview image in steps of scaled dot size
                for (let y = 0; y < canvasHeight; y += previewDotSize) {
                    for (let x = 0; x < canvasWidth; x += previewDotSize) {
                        // Sample pixel at center of dot area
                        const sampleX = Math.min(x + previewDotSize / 2, canvasWidth - 1);
                        const sampleY = Math.min(y + previewDotSize / 2, canvasHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * canvasWidth) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        // Calculate brightness
                        const brightnessValue = (r + g + b) / 3;
                        
                        // Map brightness to dot size
                        const dotRadius = this.map(brightnessValue, 0, 255, previewDotSize * 0.9, 0.5);
                        
                        // Draw dot based on shape setting
                        if (dotRadius > 0.5) {
                            const centerX = x + previewDotSize / 2;
                            const centerY = y + previewDotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                this.ctx.beginPath();
                                this.ctx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                this.ctx.fill();
                            } else if (this.dotShape === 'square') {
                                this.ctx.fillRect(
                                    centerX - dotRadius / 2,
                                    centerY - dotRadius / 2,
                                    dotRadius,
                                    dotRadius
                                );
                            } else if (this.dotShape === 'mixed') {
                                // Deterministic random based on position
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    this.ctx.beginPath();
                                    this.ctx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                    this.ctx.fill();
                                } else {
                                    this.ctx.fillRect(
                                        centerX - dotRadius / 2,
                                        centerY - dotRadius / 2,
                                        dotRadius,
                                        dotRadius
                                    );
                                }
                            }
                        }
                    }
                }
                
                this.updateImageInfo();
            }

            // Helper function to mimic P5.js map function
            map(value, start1, stop1, start2, stop2) {
                return start2 + (stop2 - start2) * ((value - start1) / (stop1 - start1));
            }

            // Pan and zoom functionality
            startDrag(e) {
                this.isDragging = true;
                this.lastMouseX = e.clientX;
                this.lastMouseY = e.clientY;
            }

            endDrag() {
                this.isDragging = false;
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                this.zoom(zoomFactor);
            }

            zoom(factor) {
                this.scale *= factor;
                this.scale = Math.max(0.1, Math.min(3, this.scale));
                this.updateCanvasTransform();
            }

            resetView() {
                this.offsetX = 0;
                this.offsetY = 0;
                this.scale = 1;
                this.updateCanvasTransform();
            }

            updateCanvasTransform() {
                this.canvas.style.transform = `translate(${this.offsetX}px, ${this.offsetY}px) scale(${this.scale})`;
            }

            // Export functions - these process at full resolution
            exportSVG() {
                if (!this.uploaded || !this.originalImage) {
                    alert('Please upload an image first');
                    return;
                }

                // Generate full resolution image data for export
                this.processImage();

                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                let svg = `<?xml version="1.0" encoding="UTF-8"?>\n<svg xmlns="http://www.w3.org/2000/svg" width="${outputWidth}" height="${outputHeight}" viewBox="0 0 ${outputWidth} ${outputHeight}">`;
                svg += `<rect width="${outputWidth}" height="${outputHeight}" fill="white"/>`;
                
                const pixels = this.processedImageData.data;
                let dotCount = 0;

                // Generate SVG dots at full resolution
                for (let y = 0; y < outputHeight; y += this.dotSize) {
                    for (let x = 0; x < outputWidth; x += this.dotSize) {
                        const sampleX = Math.min(x + this.dotSize / 2, outputWidth - 1);
                        const sampleY = Math.min(y + this.dotSize / 2, outputHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * outputWidth) * 4;Width) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        const brightnessValue = (r + g + b) / 3;
                        const dotRadius = this.map(brightnessValue, 0, 255, this.dotSize * 0.9, 0.5);
                        
                        if (dotRadius > 0.5) {
                            const centerX = x + this.dotSize / 2;
                            const centerY = y + this.dotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'square') {
                                svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'mixed') {
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                                } else {
                                    svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                                }
                            }
                            dotCount++;
                        }
                    }
                }
                
                svg += '</svg>';
                
                // Generate timestamp filename
                const now = new Date();
                const timestamp = `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1)
                    .toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now
                    .getHours().toString().padStart(2, '0')}${now.getMinutes()
                    .toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
                
                const filename = `halftone_24x36_300dpi_${timestamp}.svg`;
                
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                this.downloadFile(blob, filename);
            }

            exportPNG() {
                if (!this.uploaded || !this.originalImage) {
                    alert('Please upload an image first');
                    return;
                }

                // Create full resolution canvas for export
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                const outputWidth = Math.round(this.widthInches * this.dpi);
                const outputHeight = Math.round(this.heightInches * this.dpi);
                
                exportCanvas.width = outputWidth;
                exportCanvas.height = outputHeight;

                // Generate full resolution image data
                this.processImage();
                
                // Clear and set white background
                exportCtx.clearRect(0, 0, outputWidth, outputHeight);
                exportCtx.fillStyle = '#ffffff';
                exportCtx.fillRect(0, 0, outputWidth, outputHeight);

                const pixels = this.processedImageData.data;
                exportCtx.fillStyle = this.dotColor;

                // Draw at full resolution
                for (let y = 0; y < outputHeight; y += this.dotSize) {
                    for (let x = 0; x < outputWidth; x += this.dotSize) {
                        const sampleX = Math.min(x + this.dotSize / 2, outputWidth - 1);
                        const sampleY = Math.min(y + this.dotSize / 2, outputHeight - 1);
                        const index = (Math.floor(sampleX) + Math.floor(sampleY) * outputWidth) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        const brightnessValue = (r + g + b) / 3;
                        const dotRadius = this.map(brightnessValue, 0, 255, this.dotSize * 0.9, 0.5);
                        
                        if (dotRadius > 0.5) {
                            const centerX = x + this.dotSize / 2;
                            const centerY = y + this.dotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                exportCtx.beginPath();
                                exportCtx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                exportCtx.fill();
                            } else if (this.dotShape === 'square') {
                                exportCtx.fillRect(
                                    centerX - dotRadius / 2,
                                    centerY - dotRadius / 2,
                                    dotRadius,
                                    dotRadius
                                );
                            } else if (this.dotShape === 'mixed') {
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    exportCtx.beginPath();
                                    exportCtx.arc(centerX, centerY, dotRadius / 2, 0, Math.PI * 2);
                                    exportCtx.fill();
                                } else {
                                    exportCtx.fillRect(
                                        centerX - dotRadius / 2,
                                        centerY - dotRadius / 2,
                                        dotRadius,
                                        dotRadius
                                    );
                                }
                            }
                        }
                    }
                }

                // Generate timestamp filename
                const now = new Date();
                const timestamp = `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1)
                    .toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now
                    .getHours().toString().padStart(2, '0')}${now.getMinutes()
                    .toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
                
                const filename = `halftone_24x36_300dpi_${timestamp}.png`;
                
                exportCanvas.toBlob((blob) => {
                    if (!blob) {
                        alert('PNG Export failed - could not create image data.');
                        return;
                    }
                    this.downloadFile(blob, filename);
                }, 'image/png', 1.0);
            }Width) * 4;
                        
                        const r = pixels[index] || 0;
                        const g = pixels[index + 1] || 0;
                        const b = pixels[index + 2] || 0;
                        
                        const brightnessValue = (r + g + b) / 3;
                        const dotRadius = this.map(brightnessValue, 0, 255, this.dotSize * 0.9, 0.5);
                        
                        if (dotRadius > 0.5) {
                            const centerX = x + this.dotSize / 2;
                            const centerY = y + this.dotSize / 2;
                            
                            if (this.dotShape === 'circle') {
                                svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'square') {
                                svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                            } else if (this.dotShape === 'mixed') {
                                const isCircle = (x * 7 + y * 13) % 17 < 8.5;
                                if (isCircle) {
                                    svg += `<circle cx="${centerX}" cy="${centerY}" r="${dotRadius / 2}" fill="${this.dotColor}"/>`;
                                } else {
                                    svg += `<rect x="${centerX - dotRadius / 2}" y="${centerY - dotRadius / 2}" width="${dotRadius}" height="${dotRadius}" fill="${this.dotColor}"/>`;
                                }
                            }
                            dotCount++;
                        }
                    }
                }
                
                svg += '</svg>';
                
                // Generate timestamp filename
                const now = new Date();
                const timestamp = `${now.getFullYear().toString().slice(-2)}${(now.getMonth() + 1)
                    .toString().padStart(2, '0')}${now.getDate().toString().padStart(2, '0')}${now
                    .getHours().toString().padStart(2, '0')}${now.getMinutes()
                    .toString().padStart(2, '0')}${now.getSeconds().toString().padStart(2, '0')}`;
                
                const filename = `halftone_${this.widthInches}x${this.heightInches}_${this.dpi}dpi_${timestamp}.svg`;
                
                const blob = new Blob([svg], { type: 'image/svg+xml' });
                this.downloadFile(blob, filename);
            }



            downloadFile(blob, filename) {
                // Try modern File System Access API first
                if (window.showSaveFilePicker) {
                    const fileExtension = filename.split('.').pop();
                    const mimeType = fileExtension === 'svg' ? 'image/svg+xml' : 'image/png';
                    
                    window.showSaveFilePicker({
                        suggestedName: filename,
                        types: [{
                            description: `${fileExtension.toUpperCase()} files`,
                            accept: {[mimeType]: [`.${fileExtension}`]},
                        }],
                    }).then(fileHandle => {
                        return fileHandle.createWritable();
                    }).then(writable => {
                        return writable.write(blob);
                    }).then(writable => {
                        return writable.close();
                    }).catch(err => {
                        if (err.name !== 'AbortError') {
                            this.fallbackDownload(blob, filename);
                        }
                    });
                } else {
                    this.fallbackDownload(blob, filename);
                }
            }

            fallbackDownload(blob, filename) {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 1000);
            }
        }

        // Initialize
        const processor = new HalftoneProcessor();
    </script>
</body>
</html>clientX;
                this.lastMouseY = e.clientY;
            }

            drag(e) {
                if (!this.isDragging) return;
                
                const deltaX = e.clientX - this.lastMouseX;
                const deltaY = e.clientY - this.lastMouseY;
                
                this.offsetX += deltaX;
                this.offsetY += deltaY;
                
                this.updateCanvasTransform();
                
                this.lastMouseX = e.
